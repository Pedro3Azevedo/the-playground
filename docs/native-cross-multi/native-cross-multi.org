#+title: Native vs Cross-Platform vs Multiplatform
#+author: Pedro Azevedo
#+bibliography: docs.bib

* Different ways to develop mobile applications

Mobile applications have become an important way to solve problems and improve people's lives in many different areas.
One of the first questoins that needs to be answered when starting to develop a mobile application is which technology to use and which solution will be the most cost-effective.
Currently, there are two main systems for mobile phones, Android and IOS. Application on these platforms are built, differently, run differently, and often follow different desing and developnment guidelines.
Let's dive deeper into the 3 different approaches: Native, Cross-Platform and Multiplatform.

** Native

Going Native, means that the app will be developed with to a specific OS, using its programming language.
To build native Android applications, developers typically use *Kotlin* or *Java*. Both language are compiled to Java Bytecode that runs on the Android Runtime (ART).
As for IOS, developers use Swift or Objective-C, mainly the first one, to build native IOS applications.

With native apps, there is no need for third-party frameworks, as the code is compiled directly into the platform's native language. This results in better performance and faster execution compare to other solutions, which will be discussed later.
In addition to performance, native developent offers security benefits, since developer can take advantage of the built-in security features of the operating system.
When it comes to  User Interface (UI) and User Experience (UX), each platform provides its own guidelines: Android follows Material Design, while IOS follows Human Interface guidelines. This consitency makes apps easier to navigate, and there is no issues in the app adptation to other devices.
Finally, native aplications can make full use of device features such as the camera, microphone and GPS, which enhances functionality and integration.
[cite:@nativebenefits]

When the goal is to deliver an application for both Android and iOS using native development, each feature must be implemented twice, once for each platform and in different programming languages.
As Roby Nagy explains in /Symplifying Application Development with Kotlin Multiplatform Mobile/ [cite:@kmm], the development cost of this approach can be expressed as:

/begin{equation}
Cost of development (n) = n * FC
/end{equation}

where /n/ represents the number of platforms and /FC/ the /feature complexity/, defined as the sum of all sub-features that compose a feature.
The figure [[fig:costNative]] , taken from Roby Nagy' book [cite:@kmm], illustrates how the development cost grows for two platforms (blue line) and three platforms (red line) as the number of features increases, assuming no cost reduction from sharing code.

#+CAPTION: Cost of native development as a function of feature comlpexity [cite:@kmm]
#+NAME: fig:costNative
[[./images/Figure_1.1_B17614_cost_of_native_dev.png]]

Beyond this calculation, additional factors complicate native development.Each platform has distict characteristics, and a solutionthat is straightforward to implement on one platform may be unavailable or significantly harder to achieve on another.
This divergence creates extra overhead in aligning features sets across platforms. So, Nagy introduces the additional component, /Synchronization Cost/, which increases in an exponential manner as the number of features and its complexity grows. the updated formula is expressed as:

/begin{equation}
Cost of development (n) = n * FC + Sync Cost ^ FC
/end{equation}

** Cross-Platform

One solution to reduce the development cost of the native approach is the use cross-platform frameworks. Some of this frameworks include Flutter and React Native, each providing their own SDKs and libraries to developing mobile applications, that can run on Android, iOS and even the Web.
At first glance, this approach appears to cut the development cost in half or even into thirds, since it is no longer necessary to implement each feature multiple times [cite:@kmm].

When using React Native, developers build applications with React components, and the logic run is JavaScript. This JavaScript code executes on a seperate thread and communicates with the native layer through a bridge. The bridge translates asynchronous, serialiable data between the two enviornments, which enables native rendering of components. However, this approach introduces overhead, resulting in a process generally slower compared to fully native applications.

As for Flutter, its architecture can be describe in three layers, as noted by Roby Nagy [cite:@kmm]. The Framework layer, where developers write the application code and the UI components, declaratively using the Dart language. The Engine layer renders Flutter widgets to a canvas called Skia Canvas, which is then passed to the final layer, the native platform. The platform displays the canvas and sends back user events to the framework [cite:@kmm].
Compare to Reac Native, Flutter often achieves better performance by relying on Android's Native Development Kit and iOS's Low-Level Virtual Machine to compile code coming from the engine, Flutter applications deliver higher execution performance.
Nevertheless, certain parts of a Flutter application may still nreed to be implemented in Java/Kotlin and Ibj-C/Swift code. Commuunication betweem these native components and the Dart code through a channel, reducing scalabiulity and being a little contraditory to the objective of sharing the code.

So, on one hand, using cross-platform frameworks can be an effective solution to develop applications for a multiple platforms, when time, cost and basic interoperability is the primary concern.
On the other hand, this frameworks tend to be behind the evolution of Android and iOS, and cannot take full advantage of each platform's features.
Roby Nagy therefore refines the development-cost equation as:

/begin{equation}
Cost of Development (n) = FC * (1 + Cost of going Native)
/end{equation}

In this equation, /n/ is the number of platforms and /FC/ is the feature complexity.
As for the /Cost of going Native/, reflect the additional effort required when some parts must be implemented with native code.
Its value depends on the level of interoperability that the cross-platform framework provides with native components, which is not optimal with the ones above. When there is a necessety to implement native code, the knowladge gap between the framework and native languages adds to the expense, as well as the synchronization. [cite:@kmm]
With this, it is possible to visualize the different cost of development, adding the Cross-Platform with roadblocks. The figure [[fig:costNative]], illustrates how the cost of cross-platform development increases relative to both cost of Native and Native with Sync Costs. A roadblock occurs when a required feature cannot be implemented only with the frameworks and must instead be written in native code, producing a sudden rising in cost.
If no native features are required, cross -platform development can remain les expensive with the previous discussed limitations. However, as more features demand native implementation, the cumulative cost eventually exceeds that of a fully native approach.

#+CAPTION: Cost of cross-platform development with potential roadblocks as a function complexity[cite:@kmm]
#+NAME: fig:costCross
[[./images/Figure_1.6_B17614_cost_of_cross.png]]


** Multiplatform

Although cross-platforms frameworks solve the problem of dealing with different platforms, it is still not optimal if the application demands platform specific features, and keeping up with Android and iOS updates.
To go around this conditions, Roby Nagy refers one last approach, Kotlin Multiplatform (KMP), a multiplatform solution.
Kotlin Multiplatform is an open-source technology developed by JetBrains, that allow developers to create applications for multiple platforms in a efficient way, by reusing code across them and still having the native approach benefits.[cite:@kmpJetbrain]
As Jetbrains mentions in their website, Kotlin Multiplatform is an open-source technology developed by JetBrains, that allow developers to create applications for multiple platforms in a efficient way, by reusing code across them and still having the native approach benefits.[cite:@kmpJetbrain], developers can share code without loosing the qualities of native programming, good user experience, good app performance and having full platform capabilities, along side the benefits of the cross-platform, reducing development time, consistency in behavior in the different platforms.
With this approach, the developer has 3 options, it can share and only write a feature in Kotlin, or implement the full logic and only develop the UI natively, and finally, with Compose Multiplatform, also share the UI.[cite:@kmpJetbrain]
Jetpack Compose[cite:@jetpack-compose] is a toolkit to develop the User Interface of Android apps. It is implemented in a declarative way, compatible with Kotlin APIs, enabling developers to intuitively build fast UIs. It also supports Google's Material Design, a "open-source design system for building beutiful, usable products"[cite:@material-design].
Since 2021, developers can build shared UIs for Android, iOS, desktop and web, feeling natural on every platform with Compose Multiplatform.[cite:@compose-multiplatform]

Thompson Carter, refers in his book[cite:@kotlinInDepth] the same benefits of KMP, code reusability, faster development, reduce maintenance (as is only need to fix bugs in one place), flexibility (share code and still access platform-specific features and APIs) and community support. However, he mentions some challenges as:
- Maturity, as the KMP is recent and is still evolving, some libraries and tools may not be fully supported;
- The integration with Platform-Specific APIs can be challenging;
- The transition from single-platform development can be a bit difficult, with the introduction of new paradigms;
- And the integration with an existing project can involve significant refactoring.
